#pragma config(Sensor, in1,    IntakePotentiometer, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           leftArm,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftFront,     tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port3,           rightFront,    tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port4,           leftBack,      tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port5,           rightBack,     tmotorVex393_MC29, openLoop, reversed, driveRight)
#pragma config(Motor,  port6,           leftIntake,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightIntake,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           claw,          tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port9,           arm2,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightArm,      tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"


void driveTrainForward(int distanceForward, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[leftEncoder] < distanceForward || SensorValue[rightEncoder] < distanceForward) {
		motor[leftFront] = power;
		motor[rightFront] = power;
		motor[leftBack] = power;
		motor[rightBack] = power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void driveTrainBackward(int distanceBackward, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[leftEncoder] > distanceBackward || SensorValue[rightEncoder] > distanceBackward) {
		motor[leftFront] = -power;
		motor[rightFront] = -power;
		motor[leftBack] = -power;
		motor[rightBack] = -power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void pointTurnLeft (int leftTurnDistance, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[leftEncoder] > leftTurnDistance || SensorValue[rightEncoder] < -leftTurnDistance) {
		motor[leftFront] = -power;
		motor[leftBack] = -power;
		motor[rightFront] = power;
		motor[rightBack] = power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void pointTurnRight (int rightTurnDistance, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[leftEncoder] < rightTurnDistance || SensorValue[rightEncoder] > -rightTurnDistance) {
		motor[leftFront] = power;
		motor[leftBack] = power;
		motor[rightFront] = -power;
		motor[rightBack] = -power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void swerveTurnRight (int leftSwerveDistance, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[leftEncoder] < leftSwerveDistance) {
		motor[leftFront] = power;
		motor[leftBack] = power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void swerveTurnLeft (int rightSwerveDistance, int power) {
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
	while (SensorValue[rightEncoder] < rightSwerveDistance) {
		motor[rightFront] = power;
		motor[rightBack] = power;
	}
	motor[leftFront] = 0;
	motor[rightFront] = 0;
	motor[leftBack] = 0;
	motor[rightBack] = 0;
}
void intakeDown (int power) {
	while (SensorValue[IntakePotentiometer] < 1670) {
		motor[leftIntake] = power;
		motor[rightIntake] = power;
	}
	motor[leftIntake] = 0;
	motor[rightIntake] = 0;
}
void intakeUp (int power) {
	while (SensorValue[IntakePotentiometer] > 250) {
		motor[leftIntake] = -power;
		motor[rightIntake] = -power;
	}
	motor[leftIntake] = 0;
	motor[rightIntake] = 0;
}

// Declare count variable to keep track of our choice (LCD)
int count = 0;

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------


void pre_auton()
{
	bStopTasksBetweenModes = true;

	// Clear Encoders
	SensorValue[rightEncoder] = 0;
	SensorValue[leftEncoder] = 0;

	//------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Stationary LEFT");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 3;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Stationary RIGHT");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "7 Pt. LEFT");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "7 Pt. RIGHT");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		case 4:
			//Display fifth choice
			displayLCDCenteredString(0, "12 Pt. LEFT");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		case 5:
			//Display sixth choice
			displayLCDCenteredString(0, "12 Pt. RIGHT");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		case 6:
			//Display seventh choice
			displayLCDCenteredString(0, "22 Pt. LEFT");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		case 7:
			//Display eighth choice
			displayLCDCenteredString(0, "22 Pt. RIGHT");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;
		}
	}
}


task autonomous()
{
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){

	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Stationary LEFT");
		displayLCDCenteredString(1, "is running!");

		// Stationary LEFT:

		// Start hold on cone
		setMotor(-90, claw);
		// Start raising the arm
		setMultipleMotors(80, rightArm, leftArm);
		// Forward into stationary goal
		driveTrainForward(791, 127);
		// Stop power to arm, let it fall down onto goal
		stopMultipleMotors(rightArm, leftArm);
		stopMotor(claw);
		// Open the claw
		setMotor(90, claw);
		delay(500);
		// Go backwards
		driveTrainBackward(-391, 127);
		stopMotor(claw);
		// Turn Left (90 degrees) towards mobile goal
		pointTurnLeft(280, 127);
		// Raise arm for intake
		setMultipleMotors(55, rightArm, leftArm);
		delay(250);
		// Put intake down
		intakeDown(127);
		stopMultipleMotors(rightArm, leftArm);
		// Go forward
		driveTrainForward(1000, 127);
		break;

	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Stationary RIGHT");
		displayLCDCenteredString(1, "is running!");

		// Stationary RIGHT:

		// Start hold on cone
		setMotor(-90, claw);
		// Start raising the arm
		setMultipleMotors(80, rightArm, leftArm);
		// Forward into stationary goal
		driveTrainForward(791, 127);
		// Stop power to arm, let it fall down onto goal
		stopMultipleMotors(rightArm, leftArm);
		stopMotor(claw);
		// Open the claw
		setMotor(90, claw);
		delay(500);
		// Go backwards
		driveTrainBackward(-391, 127);
		stopMotor(claw);
		// Turn Left (90 degrees) towards mobile goal
		pointTurnRight(280, 127);
		// Raise arm for intake
		setMultipleMotors(55, rightArm, leftArm);
		delay(250);
		// Put intake down
		intakeDown(127);
		stopMultipleMotors(rightArm, leftArm);
		// Go forward
		driveTrainForward(1000, 127);
		break;

	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "7 Pt. LEFT");
		displayLCDCenteredString(1, "is running!");

		// 7 Pt. LEFT:

		// Lift the arm up
		setMultipleMotors(45, leftArm, rightArm);
		// Close the claw on the preloaded cone
		setMotor(claw, -80);
		// Allow the arm to raise before putting the intake down (wait for .5)
		delay(500);
		// Put the mobile goal intake down
		intakeDown(90);
		// Go forward into the mobile goal
		driveTrainForward(1290, 90);
		// Intake the mobile goal
		intakeUp(90);
		// Discontinue power to the arm, allow it to fall back down
		stopMultipleMotors(leftArm, rightArm);
		// Stop power to the claw
		stopMotor(claw);
		// Open the claw for .25 seconds at 80 power
		motor[claw] = 80;
		wait1Msec(250);
		// Put the arm back up
		setMultipleMotors(45, leftArm, rightArm);
		// Move the robot backwards
		driveTrainBackward(-967, 90);
		// Turn right facing the 5 pt zone
		pointTurnLeft(-615, 90);
		// Move forward into the 5 pt zone
		driveTrainForward(100, 90);
		// Put the mobile goal intake down
		intakeDown(90);
		// Move backwards away from scored mobile goal
		driveTrainBackward(-200, 90);

		break;
	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "7 Pt. RIGHT");
		displayLCDCenteredString(1, "is running!");

		// 7 Pt. RIGHT:

		// Lift the arm up
		setMultipleMotors(45, leftArm, rightArm);
		// Close the claw on the preloaded cone
		setMotor(claw, -80);
		// Allow the arm to raise before putting the intake down (wait for .5)
		delay(500);
		// Put the mobile goal intake down
		intakeDown(90);
		// Go forward into the mobile goal
		driveTrainForward(1290, 90);
		// Intake the mobile goal
		intakeUp(90);
		// Discontinue power to the arm, allow it to fall back down
		stopMultipleMotors(leftArm, rightArm);
		// Stop power to the claw
		stopMotor(claw);
		// Open the claw for .25 seconds at 80 power
		motor[claw] = 80;
		wait1Msec(250);
		// Put the arm back up
		setMultipleMotors(45, leftArm, rightArm);
		// Move the robot backwards
		driveTrainBackward(-967, 90);
		// Turn right facing the 5 pt zone
		pointTurnRight(615, 90);
		// Move forward into the 5 pt zone
		driveTrainForward(100, 90);
		// Put the mobile goal intake down
		intakeDown(90);
		// Move backwards away from scored mobile goal
		driveTrainBackward(-200, 90);

		break;
	case 4:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "12 Pt. LEFT");
		displayLCDCenteredString(1, "is running!");

		// 12 Pt. LEFT:

		// Lift the arm up
		setMultipleMotors(55, leftArm, rightArm);
		// Close the claw on the preloaded cone
		setMotor(claw, -80);
		// Allow the arm to raise before putting the intake down (wait for .5)
		delay(500);
		// Put the mobile goal intake down
		intakeDown(100);
		// Go forward into the mobile goal
		driveTrainForward(1290, 100);
		// Intake the mobile goal
		intakeUp(100);
		// Discontinue power to the arm, allow it to fall back down
		stopMultipleMotors(leftArm, rightArm);
		// Stop power to the claw
		stopMotor(claw);
		// Open the claw for .25 seconds at 80 power
		setMotor(claw, 80);
		wait1Msec(250);
		stopMotor(claw);
		// Put the arm back up
		setMultipleMotors(55, leftArm, rightArm);
		// Move the robot backwards
		driveTrainBackward(-967, 100);
		// Turn right facing the 10 pt zone
		pointTurnLeft(-525, 90);
		// Move forward into the 10 pt zone
		driveTrainForward(545, 90);
		// Put the mobile goal intake down
		intakeDown(90);
		// Move backwards away from scored mobile goal
		driveTrainBackward(-200, 90);

		break;
	case 5:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "12 Pt. RIGHT");
		displayLCDCenteredString(1, "is running!");

		// 12 Pt. RIGHT:

		// Lift the arm up
		setMultipleMotors(55, leftArm, rightArm);
		// Close the claw on the preloaded cone
		setMotor(claw, -80);
		// Allow the arm to raise before putting the intake down (wait for .5)
		delay(500);
		// Put the mobile goal intake down
		intakeDown(100);
		// Go forward into the mobile goal
		driveTrainForward(1290, 100);
		// Intake the mobile goal
		intakeUp(100);
		// Discontinue power to the arm, allow it to fall back down
		stopMultipleMotors(leftArm, rightArm);
		// Stop power to the claw
		stopMotor(claw);
		// Open the claw for .25 seconds at 80 power
		setMotor(claw, 80);
		wait1Msec(250);
		stopMotor(claw);
		// Put the arm back up
		setMultipleMotors(55, leftArm, rightArm);
		// Move the robot backwards
		driveTrainBackward(-967, 100);
		// Turn right facing the 10 pt zone
		pointTurnRight(525, 90);
		// Move forward into the 10 pt zone
		driveTrainForward(545, 90);
		// Put the mobile goal intake down
		intakeDown(90);
		// Move backwards away from scored mobile goal
		driveTrainBackward(-200, 90);

		break;
	case 6:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "22 Pt. LEFT");
		displayLCDCenteredString(1, "is running!");

		// 22 Pt. LEFT:

		// Lift the arm up
		setMultipleMotors(45, leftArm, rightArm);
		// Close the claw on the preloaded cone
		setMotor(claw, -80);
		// Allow the arm to raise before putting the intake down (wait for .5)
		delay(150);
		// Put the mobile goal intake down
		intakeDown(127);
		// Go forward into the mobile goal
		driveTrainForward(1290, 127);
		// Intake the mobile goal
		intakeUp(127);
		// Discontinue power to the arm, allow it to fall back down
		stopMultipleMotors(leftArm, rightArm);
		// Stop power to the claw
		stopMotor(claw);
		// Open the claw for .25 seconds at 80 power
		setMotor(claw, 80);
		wait1Msec(150);
		stopMotor(claw);
		// Put the arm back up
		setMultipleMotors(45, leftArm, rightArm);
		// Move the robot backwards
		driveTrainBackward(-1100, 127);
		// Turn right facing the 5 pt zone
		pointTurnRight(550, 127);
		// Move forward into the 5 pt zone
		driveTrainForward(985, 127);
		// Put the mobile goal intake down
		// Swerve Turn
		swerveTurnLeft(540, 127);
		intakeDown(127);
		// Move backwards away from scored mobile goal
		driveTrainBackward(-300, 127);
		intakeUp(127);

		break;
	case 7:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "22 Pt. RIGHT");
		displayLCDCenteredString(1, "is running!");

		// 22 Pt. RIGHT:

		// Lift the arm up
		setMultipleMotors(45, leftArm, rightArm);
		// Close the claw on the preloaded cone
		setMotor(claw, -80);
		// Allow the arm to raise before putting the intake down (wait for .5)
		delay(150);
		// Put the mobile goal intake down
		intakeDown(127);
		// Go forward into the mobile goal
		driveTrainForward(1290, 127);
		// Intake the mobile goal
		intakeUp(127);
		// Discontinue power to the arm, allow it to fall back down
		stopMultipleMotors(leftArm, rightArm);
		// Stop power to the claw
		stopMotor(claw);
		// Open the claw for .25 seconds at 80 power
		setMotor(claw, 80);
		wait1Msec(150);
		stopMotor(claw);
		// Put the arm back up
		setMultipleMotors(45, leftArm, rightArm);
		// Move the robot backwards
		driveTrainBackward(-967, 127);
		// Turn right facing the 5 pt zone
		pointTurnRight(550, 127);
		// Move forward into the 5 pt zone
		driveTrainForward(985, 127);
		// Put the mobile goal intake down
		// Swerve Turn
		swerveTurnLeft(540, 127);
		intakeDown(127);
		// Move backwards away from scored mobile goal
		driveTrainBackward(-300, 127);
		intakeUp(127);

		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}
}

task usercontrol()
{
	while (true)
	{
		// Drive Train Full Power/65%
		if (vexRT[Btn6U] == 1) {
			motor[rightFront] = 127;
			motor[rightBack] = 127;
		}
		else if (vexRT[Btn6D] == 1) {
			motor[rightFront] = -127;
			motor[rightBack] = -127;
		}
		else if (vexRT[Btn8U] == 1) {
			motor[rightFront] = 75;
			motor[rightBack] = 75;
		}
		else if (vexRT[Btn8D] == 1) {
			motor[rightFront] = -75;
			motor[rightBack] = -75;
		}
		else {
			motor[rightFront] = 0;
			motor[rightBack] = 0;
		}
		if (vexRT[Btn5U] == 1) {
			motor[leftFront] = 127;
			motor[leftBack] = 127;
		}
		else if (vexRT[Btn5D] == 1) {
			motor[leftFront] = -127;
			motor[leftBack] = -127;
		}
		else if (vexRT[Btn7U] == 1) {
			motor[leftFront] = 75;
			motor[leftBack] = 75;
		}
		else if (vexRT[Btn7D] == 1) {
			motor[leftFront] = -75;
			motor[leftBack] = -75;
		}
		else {
			motor[leftFront] = 0;
			motor[leftBack] = 0;
		}
		// Intake
		if (vexRT[Ch2] > 15) {
			motor[leftIntake] = vexRT[Ch2] * 0.75;
			motor[rightIntake] = vexRT[Ch2] * 0.75;
		}
		else if (vexRT[Ch2] < -15) {
			motor[leftIntake] = vexRT[Ch2] * 0.75;
			motor[rightIntake] = vexRT[Ch2] * 0.75;
		}
		else {
			motor[leftIntake] = 0;
			motor[rightIntake] = 0;
		}
		// Arm control
		if (vexRT[Ch2Xmtr2] > 15) {
			motor[leftArm] = vexRT[Ch2Xmtr2];
			motor[rightArm] = vexRT[Ch2Xmtr2];
		}
		else if (vexRT[Ch2Xmtr2] < -15) {
			motor[leftArm] = vexRT[Ch2Xmtr2];
			motor[rightArm] = vexRT[Ch2Xmtr2];
		}
		else {
			motor[leftArm] = 0;
			motor[rightArm] = 0;
		}
		// arm2 control
		if (vexRT[Ch3Xmtr2] > 15) {
			motor[arm2] = vexRT[Ch3Xmtr2];
		}
		else if (vexRT[Ch3Xmtr2] < -15) {
			motor[arm2] = vexRT[Ch3Xmtr2];
		}
		else {
			motor[arm2] = 0;
		}
		// Claw control
		if (vexRT[Btn5UXmtr2] == 1) {
			motor[claw] = 75;
		}
		else if (vexRT[Btn5DXmtr2] == 1) {
			motor[claw] = -75;
		}
		else {
			motor[claw] = 0;
		}
	}
}
